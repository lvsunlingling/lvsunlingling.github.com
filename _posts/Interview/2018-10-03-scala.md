---
layout: post
title: scala-grammar
category: study
tags: 
description:
---

## Introduction

## Environmental construction
- 利用sbt构建
- repl交互环境
- 工具 idea 插件集成

## Grammer

### BASES
#### variable
- var 
- val
- lay val(只有在第一次加载赋值)

#### types
![types]({{site.url}}/assets/image/interview/25.jpg)

- u:Unit = () 相当于java中的void
- Null 
- ()Noting 程序异常中止
- var introduction = s"my name is ${name}" 

#### Block
一个表达式,最终求得的值是最后一个表达式的值

#### 分支循环
scala里面if是表达式
  
```
var a = 1
if (a != 1) "notone" //>res0:Any = ()

val l = List("alice", "bob", "cathy")

var result_for = for {
    s <- l
    s1 = s.toUpperCase() //variable binding
    if(s1 != "")
} yield(s1) //generate new collection
```

#### 异常
try{}catch{}finally{}
```
var result = try{
    Interger.parseInt("dog")
} catch {
    case _ => 0
} finally {
    println("always be printed")
}
    
}

```

match表达式
```
var result = code match {
    case 1 => "one"
    case 2 => "two"
    case _ => "others"
}
```

### Evaluation Strategy(求值策略)
- Call By Value
- Call By Name (不需要经过中间求值没有需要不会进行正式的求值)

### Higher-order function(高阶函数)
用函数作为形参或者返回值的函数
```
def operate(f: (Int, Int) => Int) = {
    f(4,4)
}

def greeting() = (name: String) => {
    "hello" + " " + name
}
```

#### Anonymous Function(匿名函数)
就是函数常量,函数文字量
```
(name: String) => {
    "hello" + " " + name
```

#### Curried Function(柯里化)
把具有多个参数的函数抓环卫一条函数链,每个节点上都是单一参数
```
def add (x: Int)(y: Int) = x + y

val addOne = curriedAdd(2)_
addOne(2)  //3
```

#### Recursive Function(递归函数)
当编译器检测到一个函数是尾递归的时候,会覆盖当前的活动记录而不是在栈中去创建一个新的
```
@annotation.tailrec
def factorial(n: Int, m: Int): Int = 
    if(n <= 0) m
    else factorial(n - 1, m * n)

factorial(5,1)
```

### collection(集合)
![types]({{site.url}}/assets/image/interview/26.jpg)
#### seq
```
val a = List(1 , 2 , 3 , 4)
val b = 0 :: a
val c = "x" :: "y" :: "z" "Nil" //从右到左连接

a.head // res1: Int = 1
a.tail // res2: Int = List(2 , 3 , 4)

Nil.isEmpty //res3: Boolean = true

//遍历
def walthru(1: List[Int]) : String = {
    if(1.isEmpty) ""
    else 1.head.toString + "" + walkthru(1.tail)
}

walthru(a)
```
