---
layout: post
title: 数据库-mysql
category: 学习
tags: 
description:
---


# 一、sql语句

## 优化

### 1.原理上
- 减少请求数据量
- 合理的使用索引,避免全表扫描
- 分步大查询(大查询)
- 分解join为多个短语句

### 2.语法上
- 最左前缀匹配原则
- 索引不能参与计算
- 尽量扩展索引
- OR 语句前后没有同时使用索引

# 二、表结构
## MyISAM 
支持表级锁。适用于选择密集型和插入密集型的表,容易崩溃,丢失数据.

## InooDB
支持事务，行级锁，外键，聚集索引适用于更新密集的表，容灾性也较好。

实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ 间隙锁（Next-Key Locking）防止幻影读。

只有在需要它不支持的特性时，才考虑使用其它存储引擎。

# 三、主从复制原理
两个线程(Sql线程和IO线程)在 Slave 端，另外一个线程(IO线程)在 Master 端。

![读写分离]({{site.url}}/assets/image/interview/3.png)

- 在每个事务更新数据完成之前，master在二进制日志记录这些改变。写入二进制日志完成后，master通知存储引擎提交事务。
- binlog 线程 ：负责将主服务器上的数据更改写入二进制日志中。
- I/O 线程 ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志中。
- SQL 线程 ：负责读取中继日志并重放其中的 SQL 语句。


# 四、索引结构

## B树
- 将相关数据尽量集中在一起，以便一次读取多个数据，减少硬盘操作次数。
子节点的值和根节点有严格对应的大小需求

- 子节点的值和根节点有严格对应的大小需求

- 分裂是把该节点中间的关键字取到父节点,两边分裂为同级子节点
![B树]({{site.url}}/assets/image/interview/4.png)

## B+树

- B+ 树元素自底向上插入
- 一个节点可以容纳多个值,只有叶子节点才记录数据，非叶子节点只包含索引
- 从根节点起随机查找（起点是指向根节点的root）； 二，顺序查找（起点是指向最小关键字的sqt）。
- 子节点的值和父节点的值有严格大小对应关系,如果某节点有a个值,那么有a + 1个子节点,假如节点内有啊a,b个值
那么第一个子节点< a,第二在ab之间,第三个比b大
- m阶越多,可存的值越多s

![B+树]({{site.url}}/assets/image/interview/5.jpg)

## 操作
进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。

插入删除操作记录会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。

## B+树对于红黑树的优势

（一）更少的查找次数

（二）利用计算机预读特性,可以访问相邻有关的节点


# 索引
索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。

## 索引类型
- B+Tree 索引(默认)
- Hash索引
- 全文索引
- 空间数据索引

## B+Tree索引的优化

### 多列索引
在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。

### 前缀索引
对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。
对于前缀长度的选取需要根据索引选择性来确定。


### 覆盖索引

索引包含所有需要查询的字段的值。
- 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。
- 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。
- 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。

## 索引优点
- 大大减少了服务器需要扫描的数据行数
- 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，也就将相邻的数据都存储在一起）。
- 帮助服务器避免进行排序和分组，也就不需要创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表）。

